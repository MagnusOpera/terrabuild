/// <summary>Builds and publishes container images using the Docker CLI. Uses the Terrabuild action name as the Docker subcommand for ad-hoc invocations and tags images with the action hash. CI pushes rely on `docker buildx imagetools` to publish the hashed image under an explicit tag.</summary>
let append_part part acc =
  match (part, acc) with
  | ("", _) -> acc
  | (_, "") -> part
  | _ -> $"{acc} {part}"

let append_csv acc value =
  match acc with
  | "" -> value
  | _ -> $"{acc},{value}"

let append_build_arg acc key value =
  append_part $"--build-arg {key}=\"{value}\"" acc

let format_platforms platforms =
  let joined = List.fold append_csv "" platforms
  match joined with
  | "" -> ""
  | _ -> $"--platform {joined}"

let format_build_args build_args =
  Map.fold append_build_arg "" build_args

let as_text value =
  value |> Option.defaultValue ""

/// <summary>Runs an arbitrary Docker CLI command (action name is forwarded to `docker`).</summary>
/// <param name="args" required="false" example="&quot;image prune -f&quot;">Arguments appended after the Docker subcommand.</param>
[<export>] let dispatch (context: { Command: string }) (args: string option) =
  let command = as_text args |> append_part context.Command
  [{ Command = "docker"; Arguments = command; ErrorLevel = 0 }]

/// <summary>Builds a Docker image and tags it with the Terrabuild hash; pushes automatically when running in CI.</summary>
/// <param name="image" required="true" example="&quot;ghcr.io/example/project&quot;">Docker image to build.</param>
/// <param name="dockerfile" required="false" example="&quot;Dockerfile&quot;">Use alternative Dockerfile. Default is Dockerfile.</param>
/// <param name="platforms" required="false" example="&quot;linux/amd64&quot;">Target platform. Default is host.</param>
/// <param name="build_args" required="false" example="{ configuration: &quot;Release&quot; }">Named arguments to build image (see Dockerfile [ARG](https://docs.docker.com/reference/dockerfile/#arg)).</param>
/// <param name="args" required="false" example="&quot;--debug&quot;">Additional arguments passed to `docker build`.</param>
[<export>] let build (context: { CI: bool; Hash: string }) (image: string) (dockerfile: string option) (platforms: string list option) (build_args: string map option) (args: string option) =
  let dockerfile = dockerfile |> Option.defaultValue "Dockerfile"
  let platforms = platforms |> Option.map format_platforms |> Option.defaultValue ""
  let build_args = build_args |> Option.map format_build_args |> Option.defaultValue ""
  let args = args |> as_text

  let command =
    ""
    |> append_part "build"
    |> append_part $"--file {dockerfile}"
    |> append_part $"--tag {image}:{context.Hash}"
    |> append_part build_args
    |> append_part platforms
    |> append_part args
    |> append_part "."

  let ops = [{ Command = "docker"; Arguments = command; ErrorLevel = 0 }]
  if context.CI then
    ops @ [{ Command = "docker"; Arguments = $"push {image}:{context.Hash}"; ErrorLevel = 0 }]
  else
    ops

/// <summary>Pushes the built image to the registry with a specific tag.</summary>
/// <param name="image" required="true" example="&quot;ghcr.io/example/project&quot;">Repository to push.</param>
/// <param name="tag" required="true" example="&quot;1.2.3-stable&quot;">Tag applied to the image (hash tag is used as the source).</param>
/// <param name="args" required="false" example="&quot;--disable-content-trust&quot;">Additional arguments passed to tagging/push.</param>
[<export>] let push (context: { CI: bool; Hash: string }) (image: string) (tag: string) (args: string option) =
  let args = args |> as_text
  let command =
    if context.CI then
      ""
      |> append_part "buildx imagetools create"
      |> append_part $"-t {image}:{tag}"
      |> append_part $"{image}:{context.Hash}"
      |> append_part args
    else
      ""
      |> append_part "tag"
      |> append_part $"{image}:{context.Hash}"
      |> append_part $"{image}:{tag}"
      |> append_part args
  [{ Command = "docker"; Arguments = command; ErrorLevel = 0 }]


type ExportFlag =
  | Dispatch
  | Default
  | Batchable
  | Never
  | Local
  | External
  | Remote

{
  [nameof dispatch] = [Dispatch; Never]
  [nameof build] = [External]
  [nameof push] = [External]
}
