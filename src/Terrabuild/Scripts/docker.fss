import "_protocol.fss" as Protocol
import "_helpers.fss" as Helpers

/// <summary>Builds and publishes container images using the Docker CLI. Uses the Terrabuild action name as the Docker subcommand for ad-hoc invocations and tags images with the action hash. CI pushes rely on `docker buildx imagetools` to publish the hashed image under an explicit tag.</summary>
let append_csv acc value =
  match acc with
  | "" -> value
  | _ -> $"{acc},{value}"

let append_build_arg acc key value =
  Helpers.append_part $"--build-arg {key}=\"{value}\"" acc

let format_platforms platforms =
  let joined = List.fold append_csv "" platforms
  match joined with
  | "" -> ""
  | _ -> $"--platform {joined}"

let format_build_args build_args =
  Map.fold append_build_arg "" build_args

/// <summary>Runs an arbitrary Docker CLI command (action name is forwarded to `docker`).</summary>
/// <param name="args" required="false" example="&quot;image prune -f&quot;">Arguments appended after the Docker subcommand.</param>
[<export>] let dispatch (context: Protocol.ActionContext) (args: string option) =
  let command = Helpers.with_args args |> Helpers.append_part context.Command
  [{ Command = "docker"; Arguments = command; ErrorLevel = 0 }]

/// <summary>Builds a Docker image and tags it with the Terrabuild hash; pushes automatically when running in CI.</summary>
/// <param name="image" example="&quot;ghcr.io/example/project&quot;">Docker image to build.</param>
/// <param name="dockerfile" required="false" example="&quot;Dockerfile&quot;">Use alternative Dockerfile. Default is Dockerfile.</param>
/// <param name="platforms" required="false" example="&quot;linux/amd64&quot;">Target platform. Default is host.</param>
/// <param name="build_args" required="false" example="{ configuration: &quot;Release&quot; }">Named arguments to build image (see Dockerfile [ARG](https://docs.docker.com/reference/dockerfile/#arg)).</param>
/// <param name="args" required="false" example="&quot;--debug&quot;">Additional arguments passed to `docker build`.</param>
[<export>] let build (context: Protocol.ActionContext) (image: string) (dockerfile: string option) (platforms: string list option) (build_args: string map option) (args: string option) =
  let dockerfile = dockerfile |> Option.defaultValue "Dockerfile"
  let platforms = platforms |> Option.map format_platforms |> Option.defaultValue ""
  let build_args = build_args |> Option.map format_build_args |> Option.defaultValue ""
  let args = args |> Helpers.with_args

  let command =
    ""
    |> Helpers.append_part "build"
    |> Helpers.append_part $"--file {dockerfile}"
    |> Helpers.append_part $"--tag {image}:{context.Hash}"
    |> Helpers.append_part build_args
    |> Helpers.append_part platforms
    |> Helpers.append_part args
    |> Helpers.append_part "."

  let ops = [{ Command = "docker"; Arguments = command; ErrorLevel = 0 }]
  if context.CI then
    ops @ [{ Command = "docker"; Arguments = $"push {image}:{context.Hash}"; ErrorLevel = 0 }]
  else
    ops

/// <summary>Pushes the built image to the registry with a specific tag.</summary>
/// <param name="image" example="&quot;ghcr.io/example/project&quot;">Repository to push.</param>
/// <param name="tag" example="&quot;1.2.3-stable&quot;">Tag applied to the image (hash tag is used as the source).</param>
/// <param name="args" required="false" example="&quot;--disable-content-trust&quot;">Additional arguments passed to tagging/push.</param>
[<export>] let push (context: Protocol.ActionContext) (image: string) (tag: string) (args: string option) =
  let args = args |> Helpers.with_args
  let command =
    if context.CI then
      ""
      |> Helpers.append_part "buildx imagetools create"
      |> Helpers.append_part $"-t {image}:{tag}"
      |> Helpers.append_part $"{image}:{context.Hash}"
      |> Helpers.append_part args
    else
      ""
      |> Helpers.append_part "tag"
      |> Helpers.append_part $"{image}:{context.Hash}"
      |> Helpers.append_part $"{image}:{tag}"
      |> Helpers.append_part args
  [{ Command = "docker"; Arguments = command; ErrorLevel = 0 }]

// Exported functions and Terrabuild execution flags.
{
  [nameof dispatch] = [Dispatch; Never]
  [nameof build] = [External]
  [nameof push] = [External]
}
