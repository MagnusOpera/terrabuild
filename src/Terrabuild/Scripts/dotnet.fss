import "_protocol.fss" as Protocol
import "_helpers.fss" as Helpers

/// <summary>.NET SDK extension for restore, build, test, pack, and publish workflows.</summary>
let project_extensions = [".csproj"; ".fsproj"; ".vbproj"; ".pssproj"; ".sqlproj"; ".dcproj"]

let first_project_file directory =
  project_extensions
  |> List.collect (fun ext ->
      Fs.enumerateFiles directory $"*{ext}"
      |> Option.defaultValue [])
  |> List.tryHead

let project_ref_from_fragment fragment =
  match String.split "Include=\"" fragment with
  | _ :: include_parts ->
      match include_parts with
      | include_part :: _ ->
          match String.split "\"" include_part with
          | project_ref :: _ ->
              if project_ref = "" then None
              else Some project_ref
          | _ -> None
      | _ -> None
  | _ -> None

let project_refs_from project_file =
  let content = Fs.readText project_file |> Option.defaultValue ""
  match String.split "<ProjectReference" content with
  | _ :: reference_fragments ->
      reference_fragments
      |> List.choose project_ref_from_fragment
      |> List.distinct
  | _ -> []

let dependency_dirs refs =
  refs
  |> List.map (String.replace "\\" "/")
  |> List.choose Fs.parentDirectory
  |> List.distinct

let quote value = $"\"{value}\""

let command_op arguments =
  { Command = "dotnet"
    Arguments = arguments
    ErrorLevel = 0 }

let xml_escape value =
  value
  |> String.replace "&" "&amp;"
  |> String.replace "<" "&lt;"
  |> String.replace ">" "&gt;"
  |> String.replace "\"" "&quot;"
  |> String.replace "'" "&apos;"

let join_lines lines =
  lines
  |> List.fold (fun current line ->
      if current = "" then line
      else $"{current}\n{line}") ""

let with_batch_solution_with_configuration (context: Protocol.ActionContext) configuration create_command =
  match context.Batch with
  | Some batch ->
      let project_files =
        batch.ProjectPaths
        |> List.choose first_project_file

      match project_files with
      | [] ->
          [ create_command "" ]
      | _ ->
          let solution_file = Fs.combinePath batch.TempDir $"{batch.Hash}.slnx"
          let project_entries =
            project_files
            |> List.map (fun project_file ->
                let escaped = project_file |> xml_escape
                $"  <Project Path=\"../{escaped}\" />")
            |> join_lines

          let solution_content =
            $"<Solution>\n{project_entries}\n</Solution>"

          Fs.writeText solution_file solution_content |> ignore
          [ create_command (quote solution_file) ]
  | _ ->
      [ create_command "" ]

let with_batch_solution (context: Protocol.ActionContext) create_command =
  with_batch_solution_with_configuration context "Release" create_command

let with_configuration configuration =
  configuration |> Option.defaultValue "Release"

/// <summary>Computes default outputs and project-reference dependencies.</summary>
/// <param name="ignores" example="[ &quot;**/*.binlog&quot; ]"></param>
/// <param name="outputs" example="[ &quot;bin/&quot; &quot;obj/&quot; &quot;**/*.binlog&quot; ]"></param>
[<export>] let defaults (context: Protocol.ActionContext) =
  let dependencies =
    context.Directory
    |> first_project_file
    |> Option.map (fun project_file -> dependency_dirs (project_refs_from project_file))
    |> Option.defaultValue []

  { Id = None; Outputs = ["bin/"; "obj/"; "**/*.binlog"]; Dependencies = dependencies }

/// <summary>Runs an arbitrary `dotnet` command (action name is forwarded to `dotnet`).</summary>
/// <param name="args" default="" example="&quot;run -- -v&quot;">Extra arguments for `dotnet`.</param>
[<export>] let dispatch (context: Protocol.ActionContext) (args: string option) =
  let command = Helpers.with_args args |> Helpers.append_part context.Command
  { Batchable = false
    Operations = [command_op command] }

/// <summary>Executes `dotnet tool ...` commands.</summary>
/// <param name="args" default="" example="&quot;install MagnusOpera.OpenApiGen&quot;">Extra arguments for `dotnet tool`.</param>
[<export>] let tool (context: Protocol.ActionContext) (args: string option) =
  let command =
    ""
    |> Helpers.append_part "tool"
    |> Helpers.append_part (Helpers.with_args args)
  { Batchable = false
    Operations = [command_op command] }

/// <summary>Restores NuGet packages for one project or a batch solution.</summary>
/// <param name="locked" default="true" example="&quot;true&quot;">Adds `--locked-mode`.</param>
/// <param name="evaluate" default="false" example="&quot;true&quot;">Adds `--force-evaluate`.</param>
/// <param name="args" default="" example="&quot;--no-dependencies&quot;">Extra `dotnet restore` arguments.</param>
[<export>] let restore (context: Protocol.ActionContext) (locked: bool option) (evaluate: bool option) (args: string option) =
  let locked = locked |> Helpers.map_true_default true "--locked-mode"
  let force_evaluate = evaluate |> Helpers.map_true "--force-evaluate"
  let args = args |> Helpers.with_args

  let create_command project_file =
    ""
    |> Helpers.append_part "restore"
    |> Helpers.append_part project_file
    |> Helpers.append_part locked
    |> Helpers.append_part force_evaluate
    |> Helpers.append_part args
    |> command_op

  { Batchable = true
    Operations = with_batch_solution context create_command }

/// <summary>Builds the project or batch solution via `dotnet build`.</summary>
/// <title>Build project.</title>
/// <param name="configuration" default="Release" example="&quot;Release&quot;">Build configuration.</param>
/// <param name="parallel" default="" example="1">Max CPU count (`-maxcpucount`).</param>
/// <param name="log" default="false" example="true">Adds `-bl`.</param>
/// <param name="restore" default="true" example="&quot;true&quot;">Runs restore before build.</param>
/// <param name="version" default="" example="&quot;1.2.3&quot;">Sets MSBuild `Version`.</param>
/// <param name="args" default="" example="&quot;--no-incremental&quot;">Extra `dotnet build` arguments.</param>
[<export>] let build (context: Protocol.ActionContext) (configuration: string option) (parallel: int option) (log: bool option) (restore: bool option) (version: string option) (args: string option) =
  let configuration = configuration |> with_configuration
  let log = log |> Helpers.map_true "-bl"
  let restore = restore |> Helpers.map_false "--no-restore"
  let maxcpucount = parallel |> Helpers.map_value (fun value -> $"-maxcpucount:{value}")
  let version = version |> Helpers.map_value (fun value -> $"-p:Version={value}")
  let args = args |> Helpers.with_args

  let create_command project_file =
    ""
    |> Helpers.append_part "build"
    |> Helpers.append_part project_file
    |> Helpers.append_part restore
    |> Helpers.append_part $"--configuration {configuration}"
    |> Helpers.append_part log
    |> Helpers.append_part maxcpucount
    |> Helpers.append_part version
    |> Helpers.append_part args
    |> command_op

  { Batchable = true
    Operations = with_batch_solution_with_configuration context configuration create_command }

/// <summary>Packs the project into a NuGet package via `dotnet pack`.</summary>
/// <param name="configuration" default="Release" example="&quot;Release&quot;">Build configuration.</param>
/// <param name="restore" default="true" example="&quot;true&quot;">Runs restore before pack.</param>
/// <param name="build" default="true" example="&quot;true&quot;">Runs build before pack.</param>
/// <param name="version" default="" example="&quot;1.0.0&quot;">Package version (`/p:Version`).</param>
/// <param name="args" default="" example="&quot;--include-symbols&quot;">Extra `dotnet pack` arguments.</param>
[<export>] let pack (context: Protocol.ActionContext) (configuration: string option) (version: string option) (restore: bool option) (build: bool option) (args: string option) =
  let configuration = configuration |> with_configuration
  let version = version |> Helpers.map_value (fun value -> $"/p:Version={value}")
  let restore = restore |> Helpers.map_false "--no-restore"
  let build = build |> Helpers.map_false "--no-build"
  let args = args |> Helpers.with_args

  let command =
    ""
    |> Helpers.append_part "pack"
    |> Helpers.append_part restore
    |> Helpers.append_part build
    |> Helpers.append_part $"--configuration {configuration}"
    |> Helpers.append_part version
    |> Helpers.append_part "/p:TargetsForTfmSpecificContentInPackage="
    |> Helpers.append_part args

  { Batchable = false
    Operations = [command_op command] }

/// <summary>Publishes binaries via `dotnet publish` for one project or a batch solution.</summary>
/// <param name="configuration" default="Release" example="&quot;Release&quot;">Build configuration.</param>
/// <param name="restore" default="true" example="&quot;true&quot;">Runs restore before publish.</param>
/// <param name="build" default="true" example="&quot;true&quot;">Runs build before publish.</param>
/// <param name="runtime" default="" example="&quot;linux-x64&quot;">Runtime identifier (`--runtime`).</param>
/// <param name="trim" default="false" example="true">Enables trimming.</param>
/// <param name="single" default="false" example="true">Enables self-contained publish.</param>
/// <param name="args" default="" example="&quot;--version-suffix beta&quot;">Extra `dotnet publish` arguments.</param>
[<export>] let publish (context: Protocol.ActionContext) (configuration: string option) (restore: bool option) (build: bool option) (runtime: string option) (trim: bool option) (single: bool option) (args: string option) =
  let configuration = configuration |> with_configuration
  let restore = restore |> Helpers.map_false "--no-restore"
  let build = build |> Helpers.map_false "--no-build"
  let runtime = runtime |> Helpers.map_value (fun value -> $"-r {value}")
  let trim = trim |> Helpers.map_true "-p:PublishTrimmed=true"
  let single = single |> Helpers.map_true "--self-contained"
  let args = args |> Helpers.with_args

  let create_command project_file =
    ""
    |> Helpers.append_part "publish"
    |> Helpers.append_part project_file
    |> Helpers.append_part restore
    |> Helpers.append_part build
    |> Helpers.append_part $"--configuration {configuration}"
    |> Helpers.append_part runtime
    |> Helpers.append_part trim
    |> Helpers.append_part single
    |> Helpers.append_part args
    |> command_op

  { Batchable = true
    Operations = with_batch_solution_with_configuration context configuration create_command }

/// <summary>Runs tests via `dotnet test`, optionally batched through a generated solution.</summary>
/// <param name="configuration" default="Release" example="&quot;Release&quot;">Build configuration.</param>
/// <param name="restore" default="true" example="&quot;true&quot;">Runs restore before tests.</param>
/// <param name="build" default="true" example="&quot;true&quot;">Runs build before tests.</param>
/// <param name="filter" default="" example="&quot;TestCategory!=integration&quot;">Filter expression (`--filter`).</param>
/// <param name="args" default="" example="&quot;--blame-hang&quot;">Extra `dotnet test` arguments.</param>
[<export>] let test (context: Protocol.ActionContext) (configuration: string option) (restore: bool option) (build: bool option) (filter: string option) (args: string option) =
  let configuration = configuration |> with_configuration
  let restore = restore |> Helpers.map_false "--no-restore"
  let build = build |> Helpers.map_false "--no-build"
  let filter = filter |> Helpers.map_value (fun value -> $"--filter \"{value}\"")
  let args = args |> Helpers.with_args

  let create_command project_file =
    ""
    |> Helpers.append_part "test"
    |> Helpers.append_part project_file
    |> Helpers.append_part restore
    |> Helpers.append_part build
    |> Helpers.append_part $"--configuration {configuration}"
    |> Helpers.append_part filter
    |> Helpers.append_part args
    |> command_op

  { Batchable = true
    Operations = with_batch_solution context create_command }

// Exported functions and Terrabuild execution flags.
{ [nameof defaults] = [Default]
  [nameof dispatch] = [Dispatch; Never]
  [nameof tool] = [Local]
  [nameof restore] = [Local]
  [nameof build] = [Remote]
  [nameof pack] = [Remote]
  [nameof publish] = [Remote]
  [nameof test] = [Remote] }
